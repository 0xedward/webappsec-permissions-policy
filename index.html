<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Mac OS X version 5.1.25">
  <title>Feature Policy</title>
  <meta charset='utf-8'>
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class=
  'remove'>
  </script>
  <script class='remove'>
  var respecConfig = {
    shortName: "feature-policy",
    specStatus: "ED",
    useExperimentalStyles: true,
    edDraftURI: "http://wicg.github.io/feature-policy/",
    editors: [{
      name: "Ilya Grigorik",
      url: "https://www.igvita.com/",
      mailto: "igrigorik@gmail.com",
      company: "Google",
      companyURL: "https://google.com/",
      w3cid: "56102"
    }, {
      name: "Mike West",
      mailto: "mkwst@google.com",
      company: "Google",
      companyURL: "https://google.com/",
      w3cid: "56384"
    }],
    wg: "WICG",
    subjectPrefix: "[feature-policy]",
    format: "markdown",
    // noLegacyStyle: true,
    otherLinks: [{
      key: 'Repository',
      data: [{
        value: 'We are on Github.',
        href: 'https://github.com/wicg/feature-policy/'
      }, {
        value: 'File a bug.',
        href: 'https://github.com/wicg/feature-policy/issues'
      }, {
        value: 'Commit history.',
        href: 'https://github.com/wicg/feature-policy/commits/gh-pages/index.html'
      }]
    }],
    localBiblio:  {
      'PERMISSION-DELEGATION': {
        title: 'Permission Delegation To Embedded Web Applications',
        href: 'https://noncombatant.github.io/permission-delegation-api/',
        authors: [
          'Raymes Khoury',
          'Chris Palmer'
        ],
        date: 'March 30 2016'
      },
      'HTTP-JFV': {
        title: 'A JSON Encoding for HTTP Header Field Values',
        href: 'https://greenbytes.de/tech/webdav/draft-reschke-http-jfv-02.html',
        authors: [
          'Julian Reschke'
        ],
        date: 'October 5 2015'
      }
    }
  };
  </script>
</head>
<body>
  <section id='abstract'>
    <p>This specification defines a mechanism that allows developers to
    selectively enable and disable use of various browser features and
    APIs.</p>
  </section>
  <section id='sotd'>
    <p>This is a <strong>work in progress</strong> and may change without any
    notices.</p>
  </section>
  <section>
    <h2>Introduction</h2>
    <p>The web-platform provides an ever-expanding set of features and APIs,
    offering richer functionality, better developer ergonomics, and improved
    performance. However, a missing piece is the ability for the developer to
    selectively enable, disable, or modify the behavior of some of these
    browser features and APIs within their application:</p>
    <ol>
      <li>The developer may want to selectively _disable_ access to certain
      browser features and APIs to "lock down" their application, as a security
      or performance precaution, to prevent own and third-party content
      executing within their application from introducing unwanted or
      unexpected behaviors within their application.</li>
      <li>The developer may want to selectively _enable_ access to certain
      browser features and APIs which may be disabled by default - e.g. some
      features may be disabled by default in embedded context unless explicitly
      enabled; some features may be subject to other policy requirements.</li>
      <li>The developer may want to use the policy to assert a promise to a
      client or an embedder about the use—or lack of thereof—of certain
      features and APIs. For example, to enable certain types of "fast path"
      optimizations in the browser, or to assert a promise about conformance
      with some requirements set by other embedders - e.g. various social
      networks, search engines, and so on.</li>
    </ol>
    <p>This specification defines a feature policy mechanism that addresses the
    above use cases.</p>
    <section>
      <h2>Examples</h2>
      <div class="example">
        <p>SecureCorp Inc. wants to disable use of WebRTC and Geolocation APIs
        within their application. It can do so by delivering the following HTTP
        response header to define a feature policy:</p>
        <pre><a>Feature-Policy</a>: {"<a data-lt=
        "disable member">disable</a>":["<a>webrtc</a>","<a>geolocation</a>"]}</pre>
        <p>Unless specified otherwise, the default <a>target</a> is "`\*`",
        which means that the specified features will be disabled for all
        browsing contexts regardless of their origin.</p>
      </div>
      <div class="example">
        <p>SecureCorp Inc. wants to disable use of Geolocation API within all
        browsing contexts whose origin is "`https://example.com`". It can do so
        by delivering the following HTTP response header to define a feature
        policy:</p>
        <pre><a>Feature-Policy</a>: {"<a data-lt=
        "disable member">disable</a>":["<a>geolocation</a>"], "<a data-lt=
        "target member">target</a>":["https://example.com"]}</pre>
        <p>The <a>target</a> is a list of one or more origins, which can
        include the applications origin and any third-party origin.</p>
      </div>
      <div class="example">
        <p>SecureCorp Inc. is hosting an application on "`https://example.com`"
        and wants to disable WebRTC on its origin but enable it for a
        whitelisted embedee ("`https://other.com`"). It can do so by delivering
        the following HTTP response header to define a feature policy:</p>
        <pre><a>Feature-Policy</a>: {"<a data-lt=
        "disable member">disable</a>":["<a>webrtc</a>"], "<a data-lt=
        "target member">target</a>":["https://example.com"]},
        {"<a data-lt=
"enable member">enable</a>":["<a>webrtc</a>"], "<a data-lt="target member">target</a>":["https://other.com"]}</pre>
        <p>Some features are disabled by default in embedded contexts. The
        enable policy allows the application to selectively enable such
        features for whitelisted origins.</p>
      </div>
      <div class="example">
        <p>FastCorp Inc. wants to disable use of synchronous `script` elements,
        synchronous `XMLHttpRequest`'s and use of `document.write` within their
        application. It can do so by delivering the following HTTP response
        header to define a feature policy:</p>
        <pre><a>Feature-Policy</a>: {"<a data-lt=
        "disable member">disable</a>":["<a>sync-xhr</a>","<a>sync-script</a>","<a>docwrite</a>"]}</pre>
      </div>
    </section>
    <section>
      <h2>Other and related mechanisms</h2>
      <p>[[HTML5]] defines a [sandbox attribute] for `iframe` elements that
      allows developers to reduce the risk of including potentially untrusted
      content by imposing restrictions on content's abilities - e.g. prevent it
      from submitting forms, running scripts and plugins, and more. The
      [sandbox directive] defined by [[CSP2]] extends this capability to any
      resource, framed or not, to ask for the same set of restrictions - e.g.
      via an HTTP response header (`Content-Security-Policy: sandbox`). These
      mechanisms enable the developer to:</p>
      <ul>
        <li>Set and customize a sandbox policy on any resource via CSP.</li>
        <li>Set and customize individual sandbox policies on each `iframe`
        element within their application.</li>
      </ul>
      <p>However, there are several limitations to the above mechanism: the
      developer cannot automatically apply a policy across all contexts, which
      makes it hard or impossible to enforce consistently in some cases (e.g.
      due to third-party content injecting frames, which the developer does not
      control); there is no mechanism to selectively enable features that may
      be off by default; the sandbox mechanism uses a whitelist approach which
      is impossible to extend without compatibility risk.</p>
      <p>Feature Policy is intended to be used in combination with the sandbox
      mechanism (i.e. it does not duplicate feature controls already covered by
      sandbox), and provides an extensible mechanism that addresses the above
      limitations.</p>
    </section>
  </section>
  <section>
    <h2>Framework</h2>
    <section>
      <h2>Policies</h2>
      <p>A <dfn>feature policy</dfn> may be applied to a [Window] or
      [WorkerGlobalScope] and consists of:</p>
      <ul>
        <li>A set of <a data-lt="directive">directives</a>.
        </li>
      </ul>
    </section>
    <section>
      <h2>Directives</h2>
      <p>Each <dfn>directive</dfn> is a tuple consisting of:</p>
      <ul>
        <li>A <dfn>target</dfn> set by the <var>target member</var>.</li>
        <li>A <dfn>disable</dfn> list set by the <var>disable
        member</var>.</li>
        <li>A <dfn>enable</dfn> list set by the <var>enable member</var>.</li>
      </ul>
      <p>The following sections define the set of known members in each JSON
      object describing the policy. Future versions of this document may define
      additional such members and user agents MUST ignore unknown members when
      parsing the object.</p>
      <section>
        <h2>The <var>target member</var></h2>
        <p>The OPTIONAL <dfn>target member</dfn> defines the scope in which the
        directive is enforced. The member's name is "`target`" and the
        recognized values are either an array of serialized origins which may
        contain the "`self`" keyword that refers to current global's origin, or
        the string "`\*`". If an unknown value is specified, or if no member
        named "`target`" is present in the object, the <a>directive</a>'s
        <a>target</a> will be set to "`\*`".</p>
      </section>
      <section>
        <h2>The <var>disable member</var></h2>
        <p>The OPTIONAL <dfn>disable member</dfn> defines the <a>disable
        policy</a> for the directive. The member's name is "`disable`" and the
        value is a list of ASCII strings.</p>
      </section>
      <section>
        <h2>The <var>enable member</var></h2>
        <p>The OPTIONAL <dfn>enable member</dfn> defines the <a>enable
        policy</a> for the directive. The member's name is "`enable`" and the
        value is a list of ASCII strings. [response]</p>
      </section>
    </section>
    <section>
      <h2>Delivery</h2>
      <section>
        <h2>`Feature-Policy` HTTP Header Field</h2>
        <p>The <dfn>Feature-Policy</dfn> HTTP header field can be used both in
        the [response] (server to client) and a [request] (client to server) to
        communicate the <a>feature policy</a>. In the former case, the server
        is communicating the desired policy that should be enforced by the
        client, and in the latter, the client is communicating the policy that
        it will enforce.</p>
        <p>The header's value is represented by the following ABNF
        [[!RFC5234]]:</p>
        <pre class="abnf">
          Disable = 1#json-field-value
                    ; See Section 2 of [[HTTP-JFV]], and Section 2 of [[RFC7159]]
        </pre>
        <p>When the user agent receives a `Feature-Policy` header field, it
        MUST <a href="#process-response-policy">process</a> and <a>enforce</a>
        the serialized policy as described in <a href=
        "#integration-with-html"></a>. When the user agent [performs a
        fetch][fetching algorithm], it MUST advertise the active <a>feature
        policy</a> as described in <a href="#integration-with-fetch"></a>.</p>
        <h2>Process response policy</h2>
        <p>Given a [response] (<var>response</var>) and a [global object]
        (<var>global</var>), this algorithm returns a <a>feature
        policy</a>.</p>
        <ol>
          <li>Abort these steps if any of the following conditions are true:
            <ol>
              <li><var>response</var>’s [HTTPS state] is not
              "<code>modern</code>", and the [origin] of <var>response</var>’s
              [url] is not [potentially trustworthy].</li>
              <li><var>response</var>’s [header list] does not contain a
              [header] whose [name] is "`Feature-Policy`".</li>
            </ol>
          </li>
          <li>Let <var>header</var> be the [value] of the [header] in
          <var>response</var>’s [header list] whose name is
          "`Feature-Policy`".</li>
          <li>Let <var>feature policy</var> be the result of executing
            <a href="#parse-policy-from-value-and-global"></a> on
            <var>header</var> and <var>global</var>.
          </li>
        </ol>
        <p class="issue">TODO: Is HTTPS restriction still necessary?</p>
      </section>
      <section>
        <h2>The `meta` element</h2>
        <p>A [Document] may deliver a policy via one or more HTML [meta]
        elements whose [http-equiv] attributes are an [ASCII case-insensitive]
        match for the string "`Feature-Policy`". For example:</p>
        <pre class="example nolinks">
&lt;meta http-equiv="Feature-Policy"
  content='{"disable": ["webrtc"]},
           {"enable":["geolocation"],"target":["https://example.com"}'&gt;
        </pre>
        <p>The `meta` policy is processed as defined in <a href=
        "#process-meta-policy"></a> and modifications to the
        [content][meta-content] attribute of a `meta` element after the element
        has been parsed MUST be ignored.</p>
        <p class="issue">TODO: talk about effect of multiple policies</p>
        <section>
          <h2>Process meta policy</h2>
          <p class="note">This section extends HTML's `meta` [pragma
          directives].</p><strong>Feature policy state
          (http-equiv="feature-policy")</strong>
          <ol>
            <li>If the `meta` element is not a child of a `head` element, abort
            these steps.</li>
            <li>If the `meta` element is preceded by `link`, `script` or
            `style` elements, abort these steps.</li>
            <li>If the `meta` element has no [content][meta-content] attribute,
            or if that attribute's value is the empty string, then abort these
            steps.</li>
            <li>Let <var>policy</var> be the result of executing <a href=
            "#parse-policy-from-value-and-global"></a> on the `meta` element's
            [content][meta-content] attribute's value and the <var>current
            document</var>'s global.
            </li>
            <li>
              <a>Enforce</a> the policy <var>policy</var>.
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h2>Parse policy from <var>value</var> and <var>global</var></h2>
        <p>Given a string (<var>value</var>) and [global object]
        (<var>global</var>) this algorithm will return a <a>feature
        policy</a>.</p>
        <ol>
          <li>Let <var>list</var> be the result of executing the algorithm
          defined in Section 4 of [[!HTTP-JFV]]. If that algorithm results in
          an error, abort these steps.</li>
          <li>Let <var>policy</var> be an empty list.</li>
          <li>For each <var>item</var> in <var>list</var>:
            <ol>
              <li>Let <var>target</var> be an empty list.</li>
              <li>If <var>item</var> has a <a>target member</a> whose value is
              an array, then for each <var>origin</var> in the array:
                <ol>
                  <li>If <var>origin</var> is an [ASCII case-insensitive] match
                  for "`self`", let <var>result</var> be the
                  <var>global</var>'s origin.</li>
                  <li>Otherwise, let <var>result</var> be the result of
                  executing the [URL parser] on <var>origin</var></li>
                  <li>If <var>result</var> is not `failure`, then append the
                  [origin of <var>result</var>][origin-of-url] to
                  <var>target</var>.</li>
                </ol>
              </li>
              <li>If <var>target</var> is still an empty list, set
              <var>target</var> to "`\*`".</li>
              <li>Let <var>disable</var> be the result of executing <a href=
              "#parse-disable-features"></a> on the <var>item</var>'s
              <a>disable member</a>'s value.
              </li>
              <li>Let <var>enable</var> be the result of executing <a href=
              "#parse-enable-features"></a> on the <var>item</var>'s <a>enable
              member</a>'s value.
              </li>
              <li>Let <var>tuple</var> be a new <a>directive</a> tuple whose
              values are set as follows:
                <dl>
                  <dt>"`target`"</dt>
                  <dd>Set to <var>target</var>.</dd>
                  <dt>"`disable`"</dt>
                  <dd>Set to <var>disable</var>.</dd>
                  <dt>"`enable`"</dt>
                  <dd>Set to <var>enable</var>.</dd>
                </dl>
              </li>
              <li>Append <var>tuple</var> to <var>policy</var>.</li>
            </ol>
          </li>
          <li>Return <var>policy</var>.</li>
        </ol>
      </section>
    </section>
  </section>
  <section>
    <h2>Disable Policy</h2>
    <p>The <dfn>disable policy</dfn> allows a developer to turn off certain
    features for a <code>Document</code> or <code>Worker</code>.</p>
    <section>
      <h2>Processing</h2>
      <section>
        <h2>Parse disable features</h2>
        <p>Given a <var>list</var>, this algorithm returns a list of <a>valid
        disable features</a>, which may be empty.</p>
        <ol>
          <li>Let <var>valid-features</var> be an empty list.</li>
          <li>If <var>list</var> is <var>null</var> or empty, return
          <var>valid-features</var>.</li>
          <li>For each <var>item</var> in <var>list</var>:
            <ol>
              <li>Convert <var>item</var> to ASCII-lowercase.</li>
              <li>If <var>item</var>'s string value is not one of the <a>valid
              disable features</a>, ignore <var>item</var>, and continue to the
              next item.
              </li>
              <li>Append <var>item</var> to <var>valid-features</var>.</li>
            </ol>
          </li>
          <li>Return <var>valid-features</var>.</li>
        </ol>
      </section>
    </section>
    <section>
      <h2>Features</h2>
      <p>This section defines the list of <dfn>valid disable features</dfn> and
      their effect when applied via a <a>directive</a> as part of a <a>feature
      policy</a>.</p>
      <section>
        <h2><dfn>`cookie`</dfn></h2>
        <p>Disables `document.cookie`: when present, the attribute's getter and
        setter will throw a <code>SecurityError</code>.</p>
        <div class="example">
          <p>Given the following header:</p>
          <pre>
  <a>Feature-Policy</a>: {"<a data-lt=
"disable member">disable</a>":["<a>cookie</a>"]}</pre>
          <p>The following JavaScript code will throw a `SecurityError`
          exception:</p>
          <pre>
  document.cookie = "a=b;Secure;SameSite";
  alert(document.cookie);</pre>
        </div>
      </section>
      <section>
        <h2><dfn>`domain`</dfn></h2>
        <p>Disables `document.domain`: when present, the attribute's getter and
        setter will throw a <code>SecurityError</code>.</p>
        <div class="example">
          <p>Given the following header:</p>
          <pre>
  <a>Feature-Policy</a>: {"<a data-lt=
"disable member">disable</a>":["<a>domain</a>"]}</pre>
          <p>The following JavaScript code will throw a `SecurityError`
          exception:</p>
          <pre>
  document.domain = "example.com";
  alert(document.domain);</pre>
        </div>
      </section>
      <section>
        <h2><dfn>`docwrite`</dfn></h2>
        <p>Disables `document.write`: when called, throws "`NotSupportedError`"
        `DOMException`.</p>
        <div class="example">
          <p>Given the following header:</p>
          <pre>
  <a>Feature-Policy</a>: {"<a data-lt=
"disable member">disable</a>":["<a>docwrite</a>"]}</pre>
          <p>The following JavaScript code will throw a `NotSupportedError`
          exception:</p>
          <pre>
  document.write("...");</pre>
        </div>
      </section>
      <section>
        <h2><dfn>`geolocation`</dfn></h2>
        <p>Disables Geolocation API. [[!GEOLOCATION-API]]</p>
      </section>
      <section>
        <h2><dfn>`midi`</dfn></h2>
        <p>Disables Web MIDI API. [[!WEBMIDI]]</p>
      </section>
      <section>
        <h2><dfn>`notifications`</dfn></h2>
        <p>Disables Notification API. [[!NOTIFICATIONS]]</p>
      </section>
      <section>
        <h2><dfn>`push`</dfn></h2>
        <p>Disables Push API. [[!PUSH-API]]</p>
      </section>
      <section>
        <h2><dfn>`sync-script`</dfn></h2>
        <p>Disables synchronous `script` elements. When this policy is set,
        such scripts are ignored by the user agent.</p>
        <div class="example">
          <p>Given the following header:</p>
          <pre>
  <a>Feature-Policy</a>: {"<a data-lt=
"disable member">disable</a>":["<a>sync-script</a>"]}</pre>
          <p>The following HTML will not result in execution of `script1.js`,
          as it has neither a [`defer`] nor an [`async`] attribute. The
          remaining scripts will execute normally because they have their
          [non-blocking] flag set.</p>
          <pre>
  &lt;script src="/script1.js"&gt;&lt;/script&gt;
  &lt;script src="/script2.js" <strong>async</strong>&gt;&lt;/script&gt;
  &lt;script src="/script3.js" <strong>defer</strong>&gt;&lt;/script&gt;
  &lt;script&gt;
    const scriptEl = document.createElement("script");
    scriptEl.src = "/script4.js";
    document.body.appendChild(scriptEl);
  &lt;/script&gt;</pre>
        </div>
      </section>
      <section>
        <h2><dfn>`sync-xhr`</dfn></h2>
        <p>Disables synchronous `XMLHttpRequest` API: when [open()
        method](xhr-open) is called with <var>async</var> argument set to
        <var>true</var>, an `InvalidAccessError` except will be thrown.</p>
        <div class="example">
          <p>Given the following header:</p>
          <pre>
  <a>Feature-Policy</a>: {"<a data-lt=
"disable member">disable</a>":["<a>sync-xhr</a>"]}</pre>
          <p>The following JavaScript code will throw a `InvalidAccessError`
          exception:</p>
          <pre>
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/foo", true);</pre>
        </div>
      </section>
      <section>
        <h2><dfn>`webrtc`</dfn></h2>
        <p>Disables WebRTC. [[!WEBRTC]]</p>
      </section>
    </section>
  </section>
  <section>
    <h2>Enable Policy</h2>
    <p>The <dfn>enable policy</dfn> allows a developer to turn on certain
    features for a <code>Document</code> or <code>Worker</code>.</p>
    <section>
      <h2>Processing</h2>
      <section>
        <h2>Parse enable features</h2>
        <p>Given a <var>list</var>, this algorithm returns a list of <a>valid
        enable features</a>, which may be empty.</p>
        <ol>
          <li>Let <var>valid-features</var> be an empty list.</li>
          <li>If <var>list</var> is <var>null</var> or empty, return
          <var>valid-features</var>.</li>
          <li>For each <var>item</var> in <var>list</var>:
            <ol>
              <li>Convert <var>item</var> to ASCII-lowercase.</li>
              <li>TODO... should we merge/refactor this with disable
              parse?</li>
              <li>Append <var>item</var> to <var>valid-features</var>.</li>
            </ol>
          </li>
          <li>Return <var>valid-features</var>.</li>
        </ol>
      </section>
    </section>
  </section>
  <section>
    <h2>Integrations</h2>
    <p>This document defines a set of algorithms which other specifications
    will use in order to implement the restrictions which Feature Policy
    defines. The integrations are outlined here for clarity, but those external
    documents are the normative references which ought to be consulted for
    detailed information.</p>
    <section>
      <h3>Integration with HTML</h3>
      <ol>
        <li>
          <code>Document</code> and <code>WorkerGlobalScope</code> objects have
          a <dfn>Feature Policy List</dfn>, which is either the empty set or a
          <a>feature policy</a>. This property is the empty set unless
          otherwise specified, and is populated via the <a href=
          "#initialize-for-global"></a> algorithm that is called during the
          "Initialising a new <code>Document</code> object" and "Run a Worker"
          algorithms.
        </li>
        <li>A <a>feature policy</a> is <dfn data-lt="enforce">enforced</dfn>
        for a [global object] by inserting it into the [global object]'s
        <a>Feature Policy list</a>.
        </li>
        <li>
          <a>Feature policy</a> is enforced during <a href=
          "#process-meta-policy">processing of the meta element’s
          http-equiv</a>.
        </li>
        <li>
          <p>`document.cookie`'s <a href=
          "https://html.spec.whatwg.org/#dom-document-cookie">getter and setter
          algorithms</a> call into the <a href="#is-feature-disabled"></a>
          algorithm to determine whether or not to throw, as follows:</p>
          <blockquote>
            <p>On getting:</p>
            <ol>
              <li>If the document is a cookie-averse Document object, return
              the empty string.</li>
              <li>If the document's origin is an opaque origin, throw a
              "`SecurityError`" `DOMException`.</li>
              <li>If the <a href="#is-feature-disabled"></a> algorithm returns
              "`Disabled`" when executed upon "`cookie`" and the document's
              global object, throw a "`SecurityError`" `DOMException`.
              </li>
              <li>Otherwise the user agent must return the cookie-string for
              the document's URL for a "non-HTTP" API, decoded using UTF-8
              decode without BOM.</li>
            </ol>
            <p>On setting:</p>
            <ol>
              <li>If the document is a cookie-averse Document object, then the
              user agent must skip the remaining substeps.</li>
              <li>If the document's origin is an opaque origin, throw a
              "`SecurityError`" `DOMException`.</li>
              <li>If the <a href="#is-feature-disabled"></a> algorithm returns
              "`Disabled`" when executed upon "`cookie`" and the document's
              global object, throw a "`SecurityError`" `DOMException`.
              </li>
              <li>Otherwise, the user agent must act as it would when receiving
              a set-cookie-string for the document's URL via a "non-HTTP" API,
              consisting of the new value encoded as UTF-8.</li>
            </ol>
          </blockquote>
        </li>
        <li>
          <p>`document.domain`'s <a href=
          "https://html.spec.whatwg.org/#dom-document-domain">getter and setter
          algorithms</a> call into the <a href="#is-feature-disabled"></a>
          algorithm to determine whether or not to throw, as follows:</p>
          <ol>
            <li>Add the following step after the current step 1 of the
            attribute's getter:
              <ol>
                <li>If the <a href="#is-feature-disabled"></a> algorithm
                returns "`Disabled`" when executed upon "`domain`" and the
                document's global object, throw a "`SecurityError`"
                `DOMException`.
                </li>
              </ol>
            </li>
            <li>Add the following step after the current step 1 of the
            attribute's setter:
              <ol>
                <li>If the <a href="#is-feature-disabled"></a> algorithm
                returns "`Disabled`" when executed upon "`domain`" and the
                document's global object, throw a "`SecurityError`"
                `DOMException`.
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          <p>[`document.write` method](docwrite-method) calls into the <a href=
          "#is-feature-disabled"></a> algorithm to determine whether or not to
          throw, as follows:</p>
          <ol>
            <li>Add the following step after the current step 1:
              <ol>
                <li>If the <a href="#is-feature-disabled"></a> algorithm
                returns "`Disabled`" when executed upon "`docwrite`" and the
                document's global object, throw a "`NotSupportedError`"
                `DOMException`.
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          <p>The "[prepare a script]" algorithm calls into <a href=
          "#is-feature-disabled"></a> algorithm to determine whether or not to
          execute a script, as follows:</p>
          <ol>
            <li>Add the following step before the current step 10 (which is the
            first of several "disabled" checks):
              <ol>
                <li>If the `script` element's "`non-blocking`" flag is unset,
                the `script`'s type is "`classic`", and the <a href=
                "#is-feature-disabled"></a> algorithm returns "`Disabled`" when
                executed upon the `script` element's node document's global
                object, then abort these steps at this point. The script is not
                executed.
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
      <div class="issue">
        Monkey-patching! As soon as we know that this is the direction we wish
        to persuse, upstream all of this.
      </div>
      <section>
        <h4 id="initialize-for-global">Initialize <var>global</var>'s Feature
        Policy from <var>response</var></h4>
        <p>Given a [response] (<var>response</var>) and a global object
        (<var>global</var>), this algorithm populates <var>global</var>'s
        <a>Feature Policy List</a></p>
        <ol>
          <li>If <var>global</var> is a `Window` and its `Document` has a
          parent browsing context or opener browsing context
          (<var>context</var>):
            <ol>
              <li>Let <var>document</var> be the active document in
              <var>context</var>.</li>
              <li>For each <var>directive</var> in <var>document</var>'s
              <a>Feature Policy List</a>:
                <ol>
                  <li>Add <var>directive</var> to <var>global</var>'s
                  `Document`'s <a>Feature Policy List</a> if any of the
                  following are true:
                    <ol>
                      <li>
                        <var>directive</var>'s <a>target</a> is "`\*`"
                      </li>
                      <li>
                        <var>directive</var>'s <a>target</a> is an array
                        containing <var>global</var>'s origin
                      </li>
                      <li><var>response</var>'s url's scheme is a local
                      scheme</li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If <var>global</var> is a `WorkerGlobalScope`:
            <ol>
              <li>For each <var>document</var> in <var>global</var>'s
                <a href="https://html.spec.whatwg.org/multipage/workers.html#the-worker's-documents">
                documents</a>:
                <ol>
                  <li>For each <var>directive</var> in <var>document</var>'s
                  <a>Feature Policy List</a>:
                    <ol>
                      <li>Add <var>directive</var> to <var>global</var>'s
                      <a>Feature Policy List</a> if either of the following are
                      true:
                        <ol>
                          <li>
                            <var>directive</var>'s <a>target</a> is "`\*`"
                          </li>
                          <li>
                            <var>directive</var>'s <a>target</a> is an array
                            containing <var>global</var>'s origin
                          </li>
                          <li><var>response</var>'s url's scheme is a local
                          scheme</li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Let <var>policy</var> be the result of executing <a href=
          "#process-response-policy"></a> on <var>response</var> and
          <var>global</var>.
          </li>
          <li>
            <a>Enforce</a> the policy <var>policy</var>.
          </li>
        </ol>
      </section>
      <section>
        <h4 id="is-feature-disabled">Is <var>feature</var> disabled for
        <var>global</var>?</h4>
        <p>Given a string (<var>feature</var>) and a global object
        (<var>global</var>), this algorithm returns "`Disabled`" if
        <var>feature</var> should be considered disabled, and "`Enabled`"
        otherwise.</p>
        <ol>
          <li>Let <var>policy</var> be <var>global</var>'s <a>Feature Policy
          List</a>
          </li>
          <li>If <var>policy</var> is empty, return "`Enabled`".</li>
          <li>For each <var>directive</var> in <var>policy</var>:
            <ol>
              <li>If <var>directive</var>'s <a>disable</a> contains
              <var>feature</var>:
                <ol>
                  <li>Return "`Disabled`".</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return "`Enabled`".</li>
        </ol>
      </section>
    </section>
    <section>
      <h2>Integration with Fetch</h2>
      <section>
        <h2>Set request policy</h2>
        <p>This monkey patches [fetching algorithm], by inserting the following
        steps after current step #4:</p>
        <ol>
          <li>If [request]'s [client] is not <var>null</var> and has a
          non-empty <a>feature policy list</a>, run the following steps:
            <ol>
              <li>Let <var>policy</var> be the [current global object]'s
              <a>feature policy list</a>.
              </li>
              <li>Let <var>serialized feature policy</var> be the result of
              executing the [sender requirements] algorithm on
              <var>policy</var>, as defined in section 3 of [[!HTTP-JFV]].</li>
              <li>[Append](header-append) <var>Feature-Policy/serialized
              feature policy</var> to request's [header list].</li>
            </ol>
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>Integration with XMLHttpRequest</h2>
      <p>The `open() method` calls into the <a href="#is-feature-disabled"></a>
      algorithm to determine whether or not to throw, as follows:</p>
      <ol>
        <li>Add the following step after the current step 3:
          <ol>
            <li>If <var>async</var> is <var>false</var> and the <a href=
            "#is-feature-disabled"></a> algorithm returns "`Disabled`" when
            executed upon "`sync-xhr`" and the document's global object, throw
            "`InvalidAccessError`" exception.
            </li>
          </ol>
        </li>
      </ol>
    </section>
  </section>
  <section>
    <h2>IANA Considerations</h2>
    <p>The permanent message header field registry should be updated with the
    following registration [[!RFC3864]]:</p>
    <dl>
      <dt>Header field name</dt>
      <dd>Feature-Policy</dd>
      <dt>Applicable protocol</dt>
      <dd>http</dd>
      <dt>Status</dt>
      <dd>standard</dd>
      <dt>Author/Change controller</dt>
      <dd>W3C</dd>
      <dt>Specification document</dt>
      <dd>
        <a href="">Feature Policy API</a>
      </dd>
    </dl>
  </section>
  <section id="privacy" class="informative">
    <h2>Privacy and Security</h2>
    <p class="issue">TODO</p>
  </section>
</body>
</html>

<!-- spec references. preserve before running tidy! -->
[sandbox attribute]: https://html.spec.whatwg.org/multipage/the-iframe-element.html#attr-iframe-sandbox
[sandbox directive]: https://www.w3.org/TR/2014/WD-CSP11-20140211/#sandbox
[window]: https://www.w3.org/TR/html5/browsers.html#dom-window
[workerglobalscope]: https://html.spec.whatwg.org/multipage/workers.html#workerglobalscope
[response]: https://fetch.spec.whatwg.org/#concept-response
[request]: https://fetch.spec.whatwg.org/#concept-request
[HTTPS state]: https://fetch.spec.whatwg.org/#concept-response-https-state
[origin]: https://url.spec.whatwg.org/#concept-url-origin
[url]: https://fetch.spec.whatwg.org/#concept-response-url
[potentially trustworthy]: https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy
[header list]: https://fetch.spec.whatwg.org/#concept-response-header-list
[header]: https://fetch.spec.whatwg.org/#concept-header
[name]: https://fetch.spec.whatwg.org/#concept-header-name
[value]: https://fetch.spec.whatwg.org/#concept-header-value
[xhr-open]: https://xhr.spec.whatwg.org/#the-open()-method
[docwrite method]: https://html.spec.whatwg.org/#dom-document-write
[async]: https://html.spec.whatwg.org/#attr-script-async
[defer]: https://html.spec.whatwg.org/#attr-script-defer
[prepare a script]: https://html.spec.whatwg.org/#prepare-a-script
[non-blocking]: https://html.spec.whatwg.org/#non-blocking
[header-append]: https://fetch.spec.whatwg.org/#concept-header-list-append
[header-list]: https://fetch.spec.whatwg.org/#concept-request-header-list
[fetching algorithm]: https://fetch.spec.whatwg.org/#fetching
[global object]: https://html.spec.whatwg.org/multipage/webappapis.html#global-object
[current global object]: https://html.spec.whatwg.org/#current-global-object
[client]: https://fetch.spec.whatwg.org/#concept-request-client
[sender requirements]: https://greenbytes.de/tech/webdav/draft-reschke-http-jfv-02.html#rfc.section.3
[non-blocking]: https://html.spec.whatwg.org/#non-blocking
[URL parser]: https://url.spec.whatwg.org/#concept-url-parser
[origin-of-url]: https://url.spec.whatwg.org/#concept-url-origin
[ascii case-insensitive]: https://html.spec.whatwg.org/multipage/infrastructure.html#ascii-case-insensitive
[document]: https://html.spec.whatwg.org/multipage/dom.html#document
[meta]: https://html.spec.whatwg.org/#the-meta-element
[http-equiv]: https://html.spec.whatwg.org/#attr-meta-http-equiv
[meta-content]: https://html.spec.whatwg.org/#attr-meta-content
[pragma directives]: https://html.spec.whatwg.org/#attr-meta-http-equiv-content-security-policy
